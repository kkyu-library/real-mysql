▣ 01장: 소개
1.1 MySQL 소개
1.2 왜 MySQL인가?

▣ 02장: 설치와 설정
2.1 MySQL 서버 설치
___2.1.1 버전과 에디션(엔터프라이즈와 커뮤니티) 선택
___2.1.2 MySQL 설치
2.2 MySQL 서버의 시작과 종료
___2.2.1 설정 파일 및 데이터 파일 준비
___2.2.2 시작과 종료
___2.2.3 서버 연결 테스트
2.3 MySQL 서버 업그레이드
___2.3.1 인플레이스 업그레이드 제약 사항
___2.3.2 MySQL 8.0 업그레이드 시 고려 사항
___2.3.3 MySQL 8.0 업그레이드
2.4 서버 설정
___2.4.1 설정 파일의 구성
___2.4.2 MySQL 시스템 변수의 특징
___2.4.3 글로벌 변수와 세션 변수
___2.4.4 정적 변수와 동적 변수
___2.4.5 SET PERSIST
___2.4.6 my.cnf 파일

▣ 03장: 사용자 및 권한
3.1 사용자 식별
3.2 사용자 계정 관리
___3.2.1 시스템 계정과 일반 계정
___3.2.2 계정 생성
3.3 비밀번호 관리
___3.3.1 고수준 비밀번호
___3.3.2 이중 비밀번호
3.4 권한(Privilege)
3.5 역할(Role)

▣ 04장: 아키텍처
4.1 MySQL 엔진 아키텍처
___4.1.1 MySQL의 전체 구조
___4.1.2 MySQL 스레딩 구조
___4.1.3 메모리 할당 및 사용 구조
___4.1.4 플러그인 스토리지 엔진 모델
___4.1.5 컴포넌트
___4.1.6 쿼리 실행 구조
___4.1.7 복제
___4.1.8 쿼리 캐시
___4.1.9 스레드 풀
___4.1.10 트랜잭션 지원 메타데이터
4.2 InnoDB 스토리지 엔진 아키텍처
___4.2.1 프라이머리 키에 의한 클러스터링
___4.2.2 외래 키 지원
___4.2.3 MVCC(Multi Version Concurrency Control)
___4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
___4.2.5 자동 데드락 감지
___4.2.6 자동화된 장애 복구
___4.2.7 InnoDB 버퍼 풀
___4.2.8 Double Write Buffer
___4.2.9 언두 로그
___4.2.10 체인지 버퍼
___4.2.11 리두 로그 및 로그 버퍼
___4.2.12 어댑티브 해시 인덱스
___4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
4.3 MyISAM 스토리지 엔진 아키텍처
___4.3.1 키 캐시
___4.3.2 운영체제의 캐시 및 버퍼
___4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조
4.4 MySQL 로그 파일
___4.4.1 에러 로그 파일
___4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)
___4.4.3 슬로우 쿼리 로그

▣ 05장: 트랜잭션과 잠금
5.1 트랜잭션
___5.1.1 MySQL에서의 트랜잭션
___5.1.2 주의사항
5.2 MySQL 엔진의 잠금
___5.2.1 글로벌 락
___5.2.2 테이블 락
___5.2.3 네임드 락
___5.2.4 메타데이터 락
5.3 InnoDB 스토리지 엔진 잠금
___5.3.1 InnoDB 스토리지 엔진의 잠금
___5.3.2 인덱스와 잠금
___5.3.3 레코드 수준의 잠금 확인 및 해제
5.4 MySQL의 격리 수준
___5.4.1 READ UNCOMMITTED
___5.4.2 READ COMMITTED
___5.4.3 REPEATABLE READ
___5.4.4 SERIALIZABLE

▣ 06장: 데이터 압축
6.1 페이지 압축
6.2 테이블 압축
___6.2.1 압축 테이블 생성
___6.2.2 KEY_BLOCK_SIZE 결정
___6.2.3 압축된 페이지의 버퍼 풀 적재 및 사용
___6.2.4 테이블 압축 관련 설정

▣ 07장: 데이터 암호화
7.1 MySQL 서버의 데이터 암호화
___7.1.1 2단계 키 관리
___7.1.2 암호화와 성능
___7.1.3 암호화와 복제
7.2 keyring_file 플러그인 설치
7.3 테이블 암호화
___7.3.1 테이블 생성
___7.3.2 응용 프로그램 암호화와의 비교
___7.3.3 테이블스페이스 이동
7.4 언두 로그 및 리두 로그 암호화
7.5 바이너리 로그 암호화
___7.5.1 바이너리 로그 암호화 키 관리
___7.5.2 바이너리 로그 암호화 키 변경
___7.5.3 mysqlbinlog 도구 활용

▣ 08장: 인덱스
8.1 디스크 읽기 방식
___8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
___8.1.2 랜덤 I/O와 순차 I/O
8.2 인덱스란?
8.3 B-Tree 인덱스
___8.3.1 구조 및 특성
___8.3.2 B-Tree 인덱스 키 추가 및 삭제
___8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
___8.3.4 B-Tree 인덱스를 통한 데이터 읽기
___8.3.5 다중 칼럼(Multi-column) 인덱스
___8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
___8.3.7 B-Tree 인덱스의 가용성과 효율성
8.4 R-Tree 인덱스
___8.4.1 구조 및 특성
___8.4.2 R-Tree 인덱스의 용도
8.5 전문 검색 인덱스
___8.5.1 인덱스 알고리즘
___8.5.2 전문 검색 인덱스의 가용성
8.6 함수 기반 인덱스
___8.6.1 가상 칼럼을 이용한 인덱스
___8.6.2 함수를 이용한 인덱스
8.7 멀티 밸류 인덱스
8.8 클러스터링 인덱스
___8.8.1 클러스터링 인덱스
___8.8.2 세컨더리 인덱스에 미치는 영향
___8.8.3 클러스터링 인덱스의 장점과 단점
___8.8.4 클러스터링 테이블 사용 시 주의사항
8.9 유니크 인덱스
___8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
___8.9.2 유니크 인덱스 사용 시 주의사항
8.10 외래키
___8.10.1 자식 테이블의 변경이 대기하는 경우
___8.10.2 부모 테이블의 변경 작업이 대기하는 경우

▣ 09장: 옵티마이저와 힌트
9.1 개요
___9.1.1 쿼리 실행 절차
___9.1.2 옵티마이저의 종류
9.2 기본 데이터 처리
___9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
___9.2.2 병렬 처리
___9.2.3 ORDER BY 처리(Using filesort)
___9.2.4 GROUP BY 처리
___9.2.5 DISTINCT 처리
___9.2.6 내부 임시 테이블 활용
9.3 고급 최적화
___9.3.1 옵티마이저 스위치 옵션
___9.3.2 조인 최적화 알고리즘
9.4 쿼리 힌트
___9.4.1 인덱스 힌트
___9.4.2 옵티마이저 힌트

▣ 10장: 실행 계획
10.1 통계 정보
___10.1.1 테이블 및 인덱스 통계 정보
___10.1.2 히스토그램
___10.1.3 코스트 모델(Cost Model)
10.2 실행 계획 확인
___10.2.1 실행 계획 출력 포맷
___10.2.2 쿼리의 실행 시간 확인
10.3 실행 계획 분석
___10.3.1 id 칼럼
___10.3.2 select_type 칼럼
___10.3.3 table 칼럼
___10.3.4 partitions 칼럼
___10.3.5 type 칼럼
___10.3.6 possible_keys 칼럼
___10.3.7 key 칼럼
___10.3.8 key_len 칼럼
___10.3.9 ref 칼럼
___10.3.10 rows 칼럼
___10.3.11 filtered 칼럼
___10.3.12 Extra 칼럼
